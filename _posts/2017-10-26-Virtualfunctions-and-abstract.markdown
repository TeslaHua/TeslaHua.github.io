---
layout: post
category: "slam"
title:  "C++中虚函数、纯虚函数与抽象基类特性"
tags: [C++,纯虚函数,虚函数,抽象类]
---

### 1.虚函数的特性

#### (1)final和override说明符   

    struct B {
		virtual void f1(int) const;
		virtual void f2();
		void f3();
	};
	struct D1: B {
		void f1(int) const override;  //正确:f1与基类中的f1匹配
        void f2(int) override;   //错误：B没有形如f2(int)的函数
        void f3() override;      //错误：f3不是虚函数
		void f4() override;      //错误：B没有名为f4的函数
	}

<!-- more -->

  我们还能把某个函数指定为final,如果我们已经把函数定义为final了，则之后任何尝试覆盖该函数的操作都将引发错误：

     struct D2 : B {
		void f1(int) const final;  //不允许后续的其他类覆盖f1(int)
	 };
     struct D3 ： D2{
     	void f2();      //正确：覆盖从间接基类B继承而来的f2
        void f1(int) const;  //错误： D2已经将f2声明为final
	 }

#### (2)含有纯虚函数的类是抽象基类（十分类似于Java中的抽象类中的抽象函数）

 和普通的虚函数不一样，一个纯虚函数无须定义。在函数体的位置（即在声明语句的分号之前）书写**" =0 "**就可以将一个虚函数说明为纯虚函数了，其中，=0 只能出现在类内部的虚函数的声明语句处,**纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法**。例如：

    virtual void f1(int) const = 0;

  含有纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。相比于虚函数而言：

    class A  
	{  
		public:  
	    virtual void foo()  
	    {  
	        cout<<"A::foo() is called"<<endl;  
	    }  
     };  
	class B:public A  
	{  
		public:  
  	    void foo()  
        {  
        	cout<<"B::foo() is called"<<endl;  
        }  
    };  
	int main(void)  
	{  
	    A *a = new B();  
	    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  
	    return 0;  
	}

 它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。 ** 虚函数只能借助于指针或者引用来达到多态的效果 **

#### (3)虚函数与纯虚函数的区别

   1.含有纯虚函数的类被称为抽象类(abstract class)，而只含有虚函数的类(class)不能被称为抽象类(abstract class)
   
   2.虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义
   
   3.虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定(run-time bind)，而且被两者修饰的函数生命周期(life recycle)也不一样
   
   4.对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定

   5.实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖
该虚函数，由多态方式调用的时候动态绑定

   6.虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数

   7.多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。
   
     a.编译时多态性：通过重载函数实现
     b 运行时多态性：通过虚函数实现






