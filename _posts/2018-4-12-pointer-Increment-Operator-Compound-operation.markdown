---
layout: post
category: "slam"
title:  "C++解指针和递增运算符的复合运算"
tags: [C++,指针,递增，复合运算]
---


### 1.递增运算符的后置版本和指针运算

   复合版本示例：

	int a={6,7,8,9,10};
	int *ptr = a;
	//先使用解引用ptr的值(6)来加上123，所以原来的6变为129，之后ptr再加1
	*(ptr++) += 123;   

   先给出代码的运算结果：

	数组a的值： a={129,7,8,9,10}; ptr指向a中7这个元素。

<!-- more -->

   普通版本示例：

	int a={6,7,8,9,10};
	int *ptr = a;
	//先使用解引用ptr的值(6)来加上123，把129赋值给左侧的ptrzhi指向的元素。注意，这里的ptr
	//还没有进行自加运算，所以129赋值给了原来的6.然后ptr再进行两次加1运算，指向8
	*(ptr++) = *(ptr++) + 123;  

   先给出代码的运算结果：

	数组a的值： a={129,7,8,9,10}; ptr指向a中8这个元素。

**分析：**

   1.后置递增运算符的优先级高于解引用运算符，*ptr++和*(ptr++)是等价的。因此ptr++把ptr的值加1，然后返回ptr的初始值的副本作为其求值结果，因此解引用运算符的运算对象是ptr未增加之前的值，最终*(ptr++)返回ptr开始时指向的那个元素，并将指针向前移动一个位置。

   2.复合赋值运算符，类似于+=，-+，*=的操作和普通的赋值语句a = a **op** b的唯一区别就是左侧运算对象的求值次数：使用复合运算符只求值一次，使用普通的运算符则求值两次，一次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。


### 1.递增运算符的前置版本和指针运算

   复合版本示例：

	int a={6,7,8,9,10};
	int *ptr = a;
	//ptr先加1，ptr指向元素7的位置,然后7+123=130，原来的7就被赋值为130
	*(++ptr) += 123;   

   先给出代码的运算结果：

	数组a的值： a={6,130,8,9,10}; ptr指向a中130这个元素。


   普通版本示例：

	int a={6,7,8,9,10};
	int *ptr = a;
	//(赋值语句是自右向左结合)右侧的ptr先加1，指向7的位置，因为解指针运算符*的优先级大于加
	//号+和赋值号=，所以赋值号左侧的的解指针运算符也要计算，ptr再次加1，指向元素8。再执行+运算符，8加上123为131，赋值
	//给赋值号左侧的ptr指向的元素8
	*(++ptr) = *(++ptr) + 123;  

   先给出代码的运算结果：

	数组a的值： a={6,7,131,9,10}; ptr指向a中131这个元素。

**分析：**

   1.前置递增运算符的优先级高于解引用运算符，*++ptr和*(++ptr)是等价的。因此++ptr先把ptr的值加1，然后返回ptr加1之后的求值结果，因此解引用运算符的运算对象是ptr增加1之后的结果值，最终*(++ptr)返回ptr加1之后指向的那个元素。

   


   



