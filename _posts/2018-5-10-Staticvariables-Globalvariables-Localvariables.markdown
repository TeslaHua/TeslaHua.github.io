---
layout: post
category: "slam"
title:  "C|C++中的静态全局变量，静态局部变量，全局变量，局部变量的区别"
tags: [C++,静态变量,全局变量，局部变量]
---

**static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。**

## 1. 面向过程中的static

全局变量、局部变量、静态全局变量、静态局部变量的区别:

C++变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

<!-- more -->

#### （1）从作用域看：

a. 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 

b. 静态局部变量具有局部作用域（static），它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
 
c. 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 

d. 静态全局变量也具有全局作用域（static），它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 

#### （2）从分配内存空间看：

全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间 ,new出来的空间在堆里。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。** 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。**由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 

   1)、静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与栈变量和堆变量的区别。在指针调用的时候，如果要返回一个局部变量值，返回值可以用static模式，否则指针会飞掉。

   2)、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
 
从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。 

**Tips:**

   A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；

   B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；

   C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；

   D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)

   E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。 


--------------------------------------------------------------------

static全局变量 --> 全局变量: 改变作用范围，不改变存储位置。

static局部变量 --> 局部变量: 改变存储位置，不改变作用范围。

静态函数：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。 

如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。 

--------------------------------------------------------------------

## 2. 面向对象的static关键字（类中的static关键字） 

#### （1）静态数据成员 

静态数据成员有以下特点： 

1)、对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷 贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共 用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； 

2)、静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员； 

3)、静态数据成员和普通数据成员一样遵从public,protected,private访问规则； 

4)、因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； 故可以直接通过 “<类类型名>::<静态成员名>”调用。

静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： 

    ＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ 

类的静态数据成员有两种访问形式： 

    ＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞ 

如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； 
静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这 有两个好处：

第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。

第二，一旦利息需要改变时，只要改变一次， 则所有存款类对象的利息全改变过来了。

同全局变量相比，使用静态数据成员有两个优势： 

　　a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
 
　　b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能； 

#### （2）静态成员函数 

与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部 实现，属于类定义的一部分。 普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this 是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指 针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。
 
关于静态成员函数，可以总结为以下几点： 

   a. 出现在类体外的函数定义不能指定关键字static； 

   b. 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 

   c. 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 

   d. 静态成员函数不能访问非静态成员函数和非静态数据成员； 

   e. 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
 
   f. 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式调用类的静态成员函数。 

	＜类名＞::＜静态成员函数名＞（＜参数表＞） 


#### （3）注意事项

   1) 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 
   了它仅能访问类的静态数据和静态成员函数;

   2) 不能将静态成员函数定义为虚函数;
 
   3) 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 
   ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”;

   4) 由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 
   产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W 
   indow系统结合，同时也成功的应用于线程函数身上;
 
   5) static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 
   时间，节省了子类的内存空间;

   6) 静态数据成员在<定义或说明>时前面加关键字static;
 
   7) 静态数据成员是静态存储的，所以必须对它进行初始化;
 
   8) 静态成员初始化与一般数据成员初始化不同: 
   初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆； 
   初始化时不加该成员的访问权限控制符private，public等； 
   初始化时使用作用域运算符来标明它所属类； 
   所以我们得出静态数据成员初始化的格式： 
   <数据类型><类名>::<静态数据成员名>=<值> 

   9) 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。


   参考自： <https://blog.csdn.net/h_wlyfw/article/details/21005533>
